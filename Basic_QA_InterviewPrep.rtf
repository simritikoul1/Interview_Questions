{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1033{\fonttbl{\f0\fnil\fcharset0 Calibri;}}
{\*\generator Riched20 10.0.19041}\viewkind4\uc1 
\pard\ri-1016\sa200\sl276\slmult1\qc\tx9656\ul\b\i\f0\fs32\lang9 Basic Interview Questions\par

\pard\ri-972\sa200\sl276\slmult1\qc\tx9066\tx9394\par

\pard\sa200\sl240\slmult1\ulnone\i0\fs24 1. Software Testing Life Cycle (STLC)\par
\b0 => \b STLC \b0 is a systemic approach to testing a software application.\par
\tab 1. Reuirement Analysis (gather info for priority)\par
\tab 2. Test Planning (Preparation of document, test tool, test effortestimation)\par
\tab 3. Test case development (Testscript/case/data)\par
\tab 4. Test environment setup (smoke test)\par
\tab 5. Test execution (Execute test as per plan)\par
\tab 6. Test cycle closure (Test cycle completition, time, quality - Reports)\par
\par
\b 2. Defect/Bug life cycle\par
\b0 =>  New -> Assigned -> Open -> Fixed -> Pending retest -> Retest -> Verified -> Closed\par
\tab\tab\tab      |                                                       |\par
\tab\tab\tab Duplicate, Rejected, Deffered - Not a bug\par
From Retest to open if the bug is Failed.\par
\par
\b 3. TestCases \b0 => A set of actions performed on a system to determine if it satisfies software reuirements and functions correctly.\par
\par
\b 4. TestPlan\b0  => is a document that defines scope, objective, approach, and emphasis of a software testing initiative.\par
\b\par
5. TestStrategy\b0  => is a set of guidelines that describe the test design and how to perform testing. \par
It is a detailed description of all the steps to test a particular functionality of the software.\par
\b\par
6. Difference in Regression Testing & Retesting.\b0\par
=> \b Regression Testing\b0  is to ensure that changes have not affected the uchanged part of the product. Whereas, \b Retesting\b0  is used only for failed test cases.\par
\b\par
7. What does QA document includes.\par
\b0 => Testing strategy, Test plans, Test cases, Test scripts, Test data, Test logs, Bug reports.\par
\par
\b 8. Xpath \b0 => To uniquely identify the XML document which can be used to extract info like the element or attribute.\par
or \par
XPath is a syntax for finding elements on web pages.\par
or\par
used to navigate and select elements within an HTML or XML document\par
\par
\b 9. Types of Xpath\b0\par
=> \b Absolute XPath:\b0  starts from the root node (/) of the document and provides the full path to the desired element.\par
eg syntax: '/html/body/div[1]/form/input[2]'\par
*Any change in the structure of the document may cause the XPath expression to fail.\par
\b Relative XPath\b0 : starts with the reference of the current node and provides the path from that node to the desired element.\par
eg syntax: '//input[@id='username']'\par
*Relative XPath expressions are more flexible and recommended for automation testing.\par
\b\par
10. Types of XPath Locators\b0\par
=> ID, Classname, Link Text, Name, XPath(XML Path), CSS Path\par
\b\par
11. Alpha and Beta Testing\b0\par
=> Alpha testing is done by tester whereas Beta Testing is done by user.\par
UAT(User Acceptance Testing) and Beta testing are closely related. UAT is never a \b public\b0  release.\par
\par
\b 12. Agile and Scrum methodologies\par
\b0 =>  used in software development and testing to manage and deliver projects in an iterative and incremental manner.\par
\b Agile\b0  is an incremental approach to software development and project management. It emphasizes flexibility, collaboration, and customer feedback throughout the development process.\par
\b Scrum\b0  is one of the most popular Agile frameworks for managing software development projects. It provides a structured approach to planning, executing, and delivering work in short iterations called sprints.\par
\par
\b 13. POM(Page Object Model)\b0\par
=> is a design pattern used in test automation to enhance test maintenance, reduce code duplication, and improve readability. It aims to separate the test logic from the UI details.\par
Advantages of POM:\par
1. Code Reusability\par
2. Maintenance\par
3. Readability\par
\par
\b 14. Functional Testing\b0\par
=> Functional testing verifies that the software functions according to the specified requirements and performs the intended functions correctly.\par
Examples include unit testing, integration testing, system testing, and acceptance testing.\par
\par
\b 15. Non-functional Testing\b0\par
=> Non-functional testing focuses on aspects other than the functionality of the software, such as performance, security, usability, reliability, and scalability.\par
Examples include performance testing, security testing, usability testing, reliability testing, and compatibility testing.\par
\par
\b 16. Manual Testing\b0\par
=> Manual testing involves executing test cases manually without the use of automated tools or scripts.\par
Testers simulate real user scenarios to identify defects, inconsistencies, or issues in the software.\par
\par
\b 17. Automated Testing\b0\par
=> Automated testing involves using tools and scripts to execute test cases automatically without human intervention.\par
Automated tests can be repeated easily, reduce human error, and accelerate the testing process.\par
Examples include unit testing, regression testing, and end-to-end testing using frameworks like Selenium, TestCafe, or JUnit.\par
\par
\b 18. White-box Testing\b0\par
=> White-box testing, also known as structural testing or code-based testing, involves testing the internal structure, logic, and code paths of the software.\par
Testers have access to the source code and use techniques like code coverage analysis to ensure thorough testing.\par
Examples include statement coverage, branch coverage, and path coverage. \par
\par
\b 19. Black-box Testing\b0\par
=> Black-box testing focuses on testing the functionality of the software without knowledge of its internal structure or code implementation.\par
Testers interact with the software based on the specified requirements and expected behavior.\par
Examples include functional testing, system testing, and acceptance testing.\par
\par
\b 20. Regression Testing\b0  \par
=> Regression testing ensures that new changes or modifications to the software do not affect existing functionality.\par
It involves re-running previously executed test cases to detect regressions or unintended side effects.\par
\par
\b 21. Integration Testing\b0\par
=> Integration testing verifies that individual software components or modules work together as expected when integrated into a larger system.\par
It ensures smooth communication and interaction between different parts of the software.\par
\par
\b 22. System Testing\b0\par
=> System testing evaluates the entire software system as a whole to ensure that it meets the specified requirements and functions correctly in its intended environment.\par
It verifies the system's behavior, performance, and reliability under different scenarios.\par
\par
\b 23. User Acceptance Testing (UAT)\b0\par
=> User acceptance testing involves testing the software from an end-user's perspective to validate whether it meets the user's requirements and expectations.\par
\par
\b 24. Performance Testing\par
\b0 => It is a testing measure that evaluates the speed, responsiveness and stability of a computer network, software program or device under workload.\par
\par
\b 25. End-to-End (E2E) Testing\b0\par
=> End-to-End testing verifies the entire software system's functionality from start to finish, simulating real user scenarios and interactions across multiple subsystems or components.\par
\par
\b 26. System Testing\b0\par
=> System testing verifies the behavior and functionality of a complete, integrated system to ensure that it meets specified requirements and quality standards.\par
\par
\b 27. Adhoc Testing\b0\par
=> Ad-hoc testing is an informal and unstructured approach to software testing, typically performed without predefined test plans, test cases, or formal documentation.\par
It involves exploratory testing, where testers spontaneously and intuitively explore the software application to uncover defects, anomalies, or areas of improvement.\par
\par
\b 28. Sanity Testing\b0\par
=> It verifies specific functionalities or modules of the software to ensure that the recent changes or bug fixes have not adversely affected them.\par
\par
\b 29. Smoke Testing\b0\par
=> It ensures that the essential and critical functionalities of the software application are working correctly after a new build or release. It focuses on identifying major flaws that would prevent further testing.\par
}
 